<!DOCTYPE html>
<html>
<head>
    <meta charset="ISO-8859-1">
    <title>Selenium</title>
    <!-- favicon -->

    <link rel="icon" type="images/x-icon" href="favicon.png" />
    <!-- web-fonts -->
    <link href="https://fonts.googleapis.com/css?family=Hind:300,400,500,600,700" rel="stylesheet">

    <!-- font-awesome -->
    <link href="css/font-awesome.min.css" rel="stylesheet">

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- owl carousal -->
    <link href="css/owl.carousel.css" rel="stylesheet">

    <!-- Style CSS -->
    <link href="css/style.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>

<div id="main-wrapper">
    <!-- Page Preloader -->
    <div id="preloader">
        <div id="status">
            <div class="status-mes"></div>
        </div>
    </div>

    <header class="header">
        <div class="container">
            <div class="row">
                <div class="col-md-3">
                </div>
            </div>
        </div>
        <div class="col-md-9">
            <div class="name-wrapper">
                <h1 class="name">Selenium</h1>
            </div>
        </div>
    </header>

</div>
<div id="accordion">
    <div class="card">
        <div class="card-header" id="headingOne">
            <h5 class="mb-0">
                <button class="btn btn-link" data-toggle="collapse" data-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
                    Components of Selenium,Selenium Architecture,Basic code for browser invocation.
                </button>
            </h5>
        </div>

        <div id="collapseOne" class="collapse" aria-labelledby="headingOne" data-parent="#accordion">
            <div class="card-body">
      <pre>
      Components of Selenium :
          Selenium IDE : browser based plugin tool, which helps to record the manual UI flows and run it again.
          Web driver : it is web-framework allows user to write the script to automate the functional web ui test.
                       helps in writing scripts in various language java,c#,python,ruby. etc.
                       once scripts are written it can be executed. required particular browser web-driver.
          Selenium GRID : It allows scripts written using selenium to test on cross browser also enabling parallel
                          execution on different slave machine from hub node.
      </pre>
                <br>
      <pre>
      Selenium Architecture :
          The selenium webdriver works as a API calls which backendly calls get and post method
          depending on the code.
          this all calls are in JSON format.
          <img alt="Selenium Architecture" src="selenium%20architecture.png">
      </pre>
                <br>
       <pre>
           Basic code for browser invocation :
           There are two ways we can write the code 1.giving path of driver 2.dynamically assigning driver path
           1. in this approach we need to download the driver as per requirement of browser, and
           also we need to check which browser version is installed in system. once the browser version
           gets changed we need to update the driver . chrome,edge all browser will rly on their
           existing drivers. there is no common driver.
           code:
           System.setProperty("webdriver.chrome.driver","D:/pathTodriver/chromedriver.exe");
           ChromeDriver driver = new ChromeDriver();
           driver.get(url);
           System.setProperty("webdriver.edge.driver","D:/pathTodriver/edgedriver.exe");
           EdgeDriver driver = new EdgeDriver();
           driver.get(url);

           The setProperty will set the path of driver to browser variable which will help
           driver class to know where the driver is located.

           2. with this approach we dont need to download or keep updating the driver manually
           driver will get updated with browser version automatically.
           we need to use webdriverManager to help with this.
           the manager will download the required driver and with latest required version.
           In POM file we need to add dependency for io.github.bonigarcia
           group iD :io.github.bonigarcia
           artifact id : webdrivermanager
           version:xxx
           when comes to code;
           code :
           webdriverManager.ChromeDriver().setup();
           ChromeDriver driver = new ChromeDriver();
           driver.get(url);

           for edge : webdriverManager.EdgeDriver().setup();
       </pre>
            </div>
        </div>
    </div>
</div>
<div id="accordiontwo">
    <div class="card">
        <div class="card-header" id="headingTwo">
            <h5 class="mb-0">
                <button class="btn btn-link" data-toggle="collapse" data-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                    Selenium Locators,CSS selector,XPath and axes
                </button>
            </h5>
        </div>

        <div id="collapseTwo" class="collapse" aria-labelledby="headingTwo" data-parent="#accordiontwo">
            <div class="card-body">
      <pre>
          Locators in Selenium :
          there are 8 different locators.
          ID locators is fastest as it uses DOM java script method to find element.
          1. By.className()
          2. By.name()
          3.By.tagName()
          4.By.linkText()
          5. By.partialLinkText()
          6. By.cssSelector()
          7. By.id()
          8. By.xpath()
      </pre>
                <br>
      <pre>
          CSS selector:
          1. for tag name
            we need to use only tag name.
          2. for ID selector
            use #
             ex: tag#id
                 input#username
          3. for class selector
            use . (dot)
                 tag.class
                div.username
      </pre>
                <br>
      <pre>
       XPath :
          XML path Language
          basic format of xpath : //tagName[@attribute='value']
          There are two different type of xpath.
          1. Absolute xpath and 2.Relative xpath
          Absolute xpath : it consist of complete path from root element of DOM
                           to the desired element.root element is body tag.
                           always starts with single slash (/)
          Relative xpath : It will have a dynamic xpath or we can say , it can start
                          from anywhere in DOM .
                          always starts with double slash (//)
       Xpath function :
          1. starts with
           //tagName[starts-with(@attribute,'value')]
          incase the starting letters are static for any attribute but the last part is
          dynamic
          //label[starts-with(@id,'message')]
          2.Contains
          //tagName[contains(@attribute,'value')]
          if we need to match string with any part of attribute value
          //label[contains(@id,'mes')]
          //a[contains(text(),'signin')]
          3.text
          //tagName[text()='visible text']
          //a[text()='click here']
          4. ends with
          //tagName[ends-with(@attribute,'value')]
          if starting of word/value is dynamic and end of value is static
          5. and , or
          //tagName[@attribute='value' and @attribute='value']
          //tagName[@attribute='value' or @attribute='value']
          //button[@id='hello' or @id='hola']

    Xpath Axes :
          1. following :
                       //tagName[@attribute='value']//following::tagName
             all following desired tagName after current node till end of DOM can be accessible.
          2. Ancestor :
                      //tagName[@attribute='value']//ancestor::tagName
             all parent and grandparent tagName of current node will be accessible.
             ancestor-or-self.
          3. Child :
                   //tagName[@attribute='value']//child::tagName
             only the child of current node is accessible. no grandchildren
          4. preceding :
                    //tagName[@attribute='value']//preceding::tagName
             all the required element before the current node till start of DOM will be accessible.
             preceding-sibling.
          5. Following Sibling :
                      //tagName[@attribute='value']//following-sibling::tagName
          6. Parent :
                     //tagName[@attribute='value']//parent::tagName
           only the parent node will be selected
          7. Self :
                      //tagName[@attribute='value']//self::tagName
          8. Descendant :
                     //tagName[@attribute='value']//descendant::tagName
          all the children and grandchildren will be accessible.
          descendant-or-self.
      </pre>
                <br>
            </div>
        </div>
    </div>
</div>
<div id="accordionthree">
    <div class="card">
        <div class="card-header" id="headingThree">
            <h5 class="mb-0">
                <button class="btn btn-link" data-toggle="collapse" data-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                    Web-driver methods and web-element methods,Select class,Frames,Alerts.
                </button>
            </h5>
        </div>

        <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-parent="#accordionthree">
            <div class="card-body">
      <pre>
          Web Driver methods :
          this below methods are helpful to interact with browser directly.
          1. get() : this is used for opening URL.
          2. getCurrentURL() : it will return the current url.
          3. getTitle() : it will return the title of the page.
          4. getPageSource() : it will return the page source ( a complete DOM structure )
          5. close() : it will close the current tab or browser. if there is only 1 tab then the browser itself gets closed.
          6. quit() : it will close the browser, even if there are 2 or more tab.
          7. findElement() : it will return the first webelement that is found or else it will return NoSuchElementException.
          8. findElements() : it will return the list of webelement, if there is no element found it will return the empty list.
          9. driver.manage().window().maxmize() : to maximize the browser.
          10. switchTo() : to swtich to different frames and tab.
                           switchTo().window(); switchTo.Frame();
          11. getWindowHandle() : it will return a unique ID for the current tab.
          12. getWindowHandles() : it will return list of all opened tab,which will be useful for switching.

          driver.get() and driver.navigate()
          driver.get() will helps to load the URL and also wait till the page is loaded completely.
          once the page is loaded it will move to next line of code. it will not maintain any navigation history.
          driver.navigate() API will have different methods.
          driver.navigate().To() : this method will also help in opening the URL and it will not wait
          until the page is loaded completely and maintains the navigation history.
          apart from To() method there are different methods available:
          .back() : to navigate back.
          .forward() : to navigate forward
          .refresh() : to refresh to current page.

          ways to refresh to page:
          driver.navigate().refresh();
          driver.get(URL):
          driver.navigate().To(URL):
          driver.sendKeys(Keys.F5);

      </pre>
                <br>
      <pre>
          Web element methods :
          the fields or element which we see on the web-page are web-element. they can be located using selenium locators.
          once the web-element is located we can use below method to perform action on it.
          1. sendKeys() : this method will send the input as a string a word or sentence to the input field on webpage. it accepts string.
          2. clear() : this method will clear all the text present in the input field.
          3. click() : this will help us click on element.
          4. getAttribute() : this will fetch the value of the required attribute of the element. it will accept the attribute name.
          5. getCSSVale() : it will return the css value of the element.
          6. getLocation() : it will return the location of webelement . the top left corner will be the location. returns Point.
          7. getSize() : it will return the hgt and width of element. returns in Dimension.
          8. getTagName() : only returns the tag name of element.
          9. getText() : it will return the text available on the elememt. if it is link or visible text.
          10. isDisplayed() : returns true or false based on whether element is displayed on webpage or not.
          11. isEnabled() : returns true or false based on whether element is enabled for action.
          12. isSelected() : return true or false based on whether element is already selected. mostly used on radio and checkbox.
          13. submit() : if the current element is within a  form then this method will be submitted to remote server.
                        and the action reload/changed the webpage this method will be blocked until the page loads completely.
                        if the element is not within a form it will throw NoSuchElementException
      </pre>
                <br>
      <pre>
          Select Class:
          there is dedicated class available in selenium for handling the dropdown. we can also use directly combination of
          click mechanism to work on dropdown element.
          this select class helps with extra functionality.
          basic code :
          webElement element = driver.findElement(By.xpath("//select[@id='gender']"));
          Select drp = new Select(element);
          below are method used for dropdown with select class:
          1. selectByIndex(int index) : it will accept index of drodown values to be selected.
          2. selectByValue(String value) : it will select the dropdown value based on value provided. exact name should be provided.
                                           value is a attribute in select webelement.
          3. selectByVisibleText(String text) : it will select the dropdown based on text visible , text has to be exact matching.
          4. isMultiple() : it will return true or false based on whether the dropdown webelement can allow user to select multiple values.
          5. getOptions() : it will return the all webelement of option present in dropdown. returns the list of webelement which then can be
                             used to fetch the text using getText() method.
          6. getFirstSelectedOption() : it will return the first selected dropdown value. returns in a form of webelement.
          7. getAllSelectedOptions() : return list of webelement of the option selected.
          8. deselectByIndex(int index)
          9. deselectByValue(String value)
          10. deselectByVisibleText(String text)
      </pre>
                <br>
      <pre>
          Frames:
          to detect or find the number of frames in webpage we can search for iframe tag in DOM.
          a frame can have inner frame too. to perform action on element which are present inside frame we need to first
          switch to the frame and then perform action or else we will get NoSuchElementException
          there are method with driver class which helps to work wih frames.
          methods:
          1. driver.swtichTo().frame(int frameIndex) : if there are mutliple iframe tag we can jump inside the particular index of frame.
          2. driver.switchTo().frame(String frameName) : provided name of frame we can switch to that frame. attribute will be name.
          3. driver.swtichTo().frame(WebElement frameElement) : find the element using locator and store it in WebElement object and pass it.
          4. driver.switchTo().parentFrame() : to move back the parent frame.
          5. driver.swtichTo().defaultContent() : to jump to the root frame that is main DOM body tag.it wil come out of all frames incase there
                                                  are inner frames.
      </pre>
                <br>
      <pre>
          Alerts :
          if amy alerts are popups after clicking on element, we can handle using selenium build in mechanism.
          this alerts are javascript based triggered.
          we can either accept or decline the alerts some alerts accepts only ok or some kind of input.
          below are methods to work on alerts.
          1. driver.switchTo().alerts().accept() : this method accept the alert and triggers user action as Yes or ok on alert.
          2. driver.switchTo().alerts().dismiss() : this method rejects the alert if alerts has cancel button.
          3. driver.switchTo().alerts().getText() : if any text contains which shows information of alert box we can capture the text.
          4. driver.swtichTo().alerts().sendKeys() : this will send inputs to the alerts if available.
      </pre>
                <br>
            </div>
        </div>
    </div>
</div>
<div id="accordionFour">
    <div class="card">
        <div class="card-header" id="headingFour">
            <h5 class="mb-0">
                <button class="btn btn-link" data-toggle="collapse" data-target="#collapseFour" aria-expanded="false" aria-controls="collapseFour">
                    Wait in selenium.
                </button>
            </h5>
        </div>

        <div id="collapseFour" class="collapse" aria-labelledby="headingFour" data-parent="#accordionFour">
            <div class="card-body">
      <pre>
          Waits :
          1. implicit wait :
          this wait will be apply globally in automation framework and applies for all webelement. it will wait for given time before throwing
          NoSuchElementException exceptions for the webelement.
          code :
          driver.manage().timeout().implicitWait(10,TimeUnit.SECONDS);
          if the element if found after 5 second, then this wait will end as this wait is dynamic.
          the max time will be set to 10 second with above code.
          throws : NoSuchElementException

          2.Explicit Wait :
          This wait applies for a paritcular webelement only, user needs to apply this wait for every element wherever required.
          this wait once apply code will wait for element until a certain condition is met for max time.
          code :
          initialize the wait.
          WebDriverWait wait = new WebDriverWait(driver,30);
          add a expected condition:
          wait.until(ExpectedConditions.visiblityOfElementLocated(By.xpath(""))).click();
          it will wait for visibility of element, once it is visible it will click on it.  it will max for 30 seconds.
          if the time exceeds and element is not found it throws TimeOutException.
          it will continously checks for the element for 30 seconds.
          there are mutliple condition available:
          A.alertIsPresent();
          B.elementSelectionStateToBe();
          C.elementToBeClickable();
          D.elementToBeSelected();
          E.frameToBeAvailableAndSwitchToIt();
          F.invisibilityOfTheElementLocated();
          E.invisibilityOfElementWithText();
          G.presenceOfAllElementLocatedBy();
          H.presenceOfElementLocated();
          I.textToBePresentLocated();
          J.titleIs();
          K.titleContains();
          L.visibilityOf();
          M.visibilityOfAllElements();

          3. Fluent Wait :
          This is very similar to explicit wait, the difference is fluent wait allows extra methods to add polling every and
          add ignoring exception.
          code:
          initialize the wait
          FluentWait wait = new FluentWait(driver);
          wait.withTimeout(30,TimeUnit.SECONDS)
          .pollingEvery(10,TimeUnit.SECONDS)
          .ignoring(ElementClickInterceptedException.class);

          use
          wait.until(ExpectedConditions.visibilityOfElement(By.xpath(""))).click();
          or we can combine multiple condition too.
          wait.until(ExpectedConditions.add(ExpectedConditions.visibilityOfElement(By.xpath("")),
          ExpectedConditions.elementToBeClickable(By.xpath("")));
      </pre>
                <br>
      <pre>
          JavaScript executor :
          This allows javascript code to execute within browser.
          there are some action which cannot be performed with webdriver script, in this case we can use of javascript executor.
          it also helps in direct interaction with the DOM.
          Code:
          JavaScriptExecutor js = (JavaScriptExecutor) driver;

          To scroll till webelement.
          js.executeScript("arguements[0].scrollIntoView(true);",driver.findElement(By.xpath("")));
          sending text :
          js.executeScript("arguements[0].value='tezt to send';",driver.findElement(By.xpath("")));
          retrieving title :
          String title = (String)js.executeScript("return document.title;");
          scroll till bottom of page:
          js.executeScript("window.scrollTo(0,document.body.scrollHeight);");
          highlight the element:
          js.executeScript("arguements[0].style.border='3px solid red'",driver.findElement(By.xpath("")));
      </pre>
                <br>
       <pre>
           Taking a screenshot:
           we need to take help from TakesScreenshot interface to take the screenshot and store it as a File.
           also we need to add dependency in pom file as commons.io

           File screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
           FileUtils.copyFile(screenshot, new File("screenshot.png"));

           To capture specific element can be done using below code:
           no need to use TakesScreenshot interface.
           File screenshot = element.getScreenshotAs(OutputType.FILE);
           FileUtils.copyFile(screenshot, new File("screenshot.png"));
       </pre>
                <br>
       <pre>
           Handle Authentication popup.
           There are some page when lauched they directly shows a popup for accepting username and password.
           this popup whithout interacting with element can be handle direclty we link.
           link :
           https://www.authwebpag.com
           we need to modify the link by adding username and password:
           the modified link will be:
           https://username:password@www.authwebpag.com
       </pre>
            </div>
        </div>
    </div>
</div>
<!-- jquery -->
<script src="js/jquery-2.1.4.min.js"></script>
<!-- Bootstrap -->
<script src="js/bootstrap.min.js"></script>
<!--owl carousal-->
<script src="js/owl.carousel.min.js"></script>
<!--theme script-->
<script src="js/scripts.js"></script>
</body>
</html>